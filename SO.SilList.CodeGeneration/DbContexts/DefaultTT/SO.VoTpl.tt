<#
//*********************************************************
//
//    Copyright (c) Microsoft. All rights reserved.
//    This code is licensed under the Microsoft Public License.
//    THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
//    ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
//    IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
//    PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//*********************************************************
#>
<#@ template language="C#" debug="false" hostspecific="true"#>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ include file="EF.Utility.CS.ttinclude"#><#@
 output extension=".cs"#><#

CodeGenerationTools code = new CodeGenerationTools(this);
MetadataLoader loader = new MetadataLoader(this);
CodeRegion region = new CodeRegion(this, 1);
MetadataTools ef = new MetadataTools(this);

string inputFile = @"..\LocalClubModel.edmx";
string suffix = "Vo"; 

EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(inputFile);
string namespaceName = code.VsNamespaceSuggestion();

EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);
WriteHeader(fileManager);

foreach (var entity in ItemCollection.GetItems<EntityType>().OrderBy(e => e.Name))
{
    fileManager.StartNewFile(entity.Name + suffix + ".cs");
    BeginNamespace(namespaceName, code);
#>
<# // ie public class myClass #>
[Table("<#=code.Escape(entity)#>", Schema = "data" )]
[Serializable]
<#=Accessibility.ForType(entity)#> <#=code.SpaceAfter(code.AbstractOption(entity))#> class <#=code.Escape(entity) + suffix#><#=code.StringBefore(" : ", code.Escape(entity.BaseType))#>
{
<#
    var propertiesWithDefaultValues = entity.Properties.Where(p => p.TypeUsage.EdmType is PrimitiveType && p.DeclaringType == entity && p.DefaultValue != null);
    var collectionNavigationProperties = entity.NavigationProperties.Where(np => np.DeclaringType == entity && np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many);
    var complexProperties = entity.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == entity);

    if (propertiesWithDefaultValues.Any() || collectionNavigationProperties.Any() || complexProperties.Any())
    {
#>
    public <#=code.Escape(entity)+suffix#>()
    {
<#
        foreach (var edmProperty in propertiesWithDefaultValues)
        {
		break; // no need
#>
        this.<#=code.Escape(edmProperty)#> = <#=code.CreateLiteral(edmProperty.DefaultValue)#>;
<#
        }

        foreach (var navigationProperty in collectionNavigationProperties)
        {
		break; // no need
#>
        this.<#=code.Escape(navigationProperty)#> = new HashSet<<#=code.Escape(navigationProperty.ToEndMember.GetEntityType())#>>();
<#
        }

        foreach (var complexProperty in complexProperties)
        {
		break; // no need
#>
        this.<#=code.Escape(complexProperty)#> = new <#=code.Escape(complexProperty.TypeUsage)#>();
<#
        }
#>
    }

<#
    }

	string keyField = "";

    var primitiveProperties = entity.Properties.Where(p => p.TypeUsage.EdmType is PrimitiveType && p.DeclaringType == entity);
    if (primitiveProperties.Any())
    {
        foreach (var edmProperty in primitiveProperties)
        {

		
		WriteDisplayName(edmProperty);
		WriteRequiredAttribute(edmProperty);
		WriteStringLengthAttribute(edmProperty);
		WriteKeyAttribute( edmProperty) ;

        WriteProperty(code, edmProperty);
		
		if(ef.IsKey(edmProperty))
			keyField = edmProperty.Name;
	
	#>

<#

        }
    }

    if (complexProperties.Any())
    {
#>

<#
        foreach(var complexProperty in complexProperties)
        {
            WriteProperty(code, complexProperty);
        }
    }

    var navigationProperties = entity.NavigationProperties.Where(np => np.DeclaringType == entity);
    if (navigationProperties.Any())
    {
#>

<#
        foreach (var navigationProperty in navigationProperties)
        {
		    //WriteNavigationPropertyAttr(code, navigationProperty);
            WriteNavigationProperty(entity, keyField, code, navigationProperty);
        }
    }
#>
}

<#
    EndNamespace(namespaceName);
}

foreach (var complex in ItemCollection.GetItems<ComplexType>().OrderBy(e => e.Name))
{
    fileManager.StartNewFile(complex.Name + ".cs");
    BeginNamespace(namespaceName, code);
#>
<#=Accessibility.ForType(complex)#> partial class <#=code.Escape(complex)#>
{
<#
    var complexProperties = complex.Properties.Where(p => p.TypeUsage.EdmType is ComplexType && p.DeclaringType == complex);
    var propertiesWithDefaultValues = complex.Properties.Where(p => p.TypeUsage.EdmType is PrimitiveType && p.DeclaringType == complex && p.DefaultValue != null);

    if (propertiesWithDefaultValues.Any() || complexProperties.Any())
    {
#>
    public <#=code.Escape(complex)#>()
    {
<#
        foreach (var edmProperty in propertiesWithDefaultValues)
        {
#>
        this.<#=code.Escape(edmProperty)#> = <#=code.CreateLiteral(edmProperty.DefaultValue)#>;
<#
        }

        foreach (var complexProperty in complexProperties)
        {
#>
        this.<#=code.Escape(complexProperty)#> = new <#=code.Escape(complexProperty.TypeUsage)#>();
<#
        }
#>
    }

<#
    }

    var primitiveProperties = complex.Properties.Where(p => p.TypeUsage.EdmType is PrimitiveType && p.DeclaringType == complex);
    if (primitiveProperties.Any())
    {
        foreach(var edmProperty in primitiveProperties)
        {
            WriteProperty(code, edmProperty);
        }
    }

    if (complexProperties.Any())
    {
#>

<#
        foreach(var edmProperty in complexProperties)
        {
            WriteProperty(code, edmProperty);
        }
    }
#>
}

<#
    EndNamespace(namespaceName);
}

if (!VerifyTypesAreCaseInsensitiveUnique(ItemCollection))
{
    return "";
}

fileManager.Process();

#>
<#+

//Split entity name by capitals
void WriteDisplayName(EdmProperty edmProperty) {
	string displayName = edmProperty.Name;
	if (!string.IsNullOrEmpty(displayName)) {
		displayName = Regex.Replace(displayName,
			"([A-Z]+)", " $1",
			RegexOptions.Compiled).Trim();
		string displayAttribute = string.Format("[DisplayName(\"{0}\")]", displayName);
#>
	<#=displayAttribute#>
<#+
	}
}


//If property is not nullable, add required attribute
void WriteRequiredAttribute(EdmProperty edmProperty) {
	if (!edmProperty.Nullable) {
#>
	[Required]
<#+
	}
}

//If property is Key, add required attribute
void WriteKeyAttribute(EdmProperty edmProperty) {
MetadataTools ef = new MetadataTools(this);
 
bool isPrimaryKey = ef.IsKey(edmProperty);

	if (isPrimaryKey) {
#>
	[Key]
<#+
	}
}

//Set StringLength if MaxLength value is present
void WriteStringLengthAttribute(EdmProperty edmProperty) { 
	Facet maxLengthfacet;
	if (edmProperty.TypeUsage.Facets.TryGetValue("MaxLength", true, out maxLengthfacet)) {
		double lengthAttribute;
		if (double.TryParse(maxLengthfacet.Value.ToString(), out lengthAttribute)) {
		string stringLengthAttribute = string.Format("[StringLength({0})]", lengthAttribute);
#>
	<#=stringLengthAttribute#>
<#+	
		}
	}
}

void WriteHeader(EntityFrameworkTemplateFileManager fileManager)
{
    fileManager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System; 
using System.ComponentModel;
using System.ComponentModel.DataAnnotations; 
using System.Data;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations.Schema;

<#+
    fileManager.EndBlock();
}

void BeginNamespace(string namespaceName, CodeGenerationTools code)
{
    CodeRegion region = new CodeRegion(this);
    if (!String.IsNullOrEmpty(namespaceName))
    {
#>
namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#+
        PushIndent(CodeRegion.GetIndent(1));
    }
}


void EndNamespace(string namespaceName)
{
    if (!String.IsNullOrEmpty(namespaceName))
    {
        PopIndent();
#>
}
<#+
    }
}

void WriteProperty(CodeGenerationTools code, EdmProperty edmProperty)
{
    WriteProperty(Accessibility.ForProperty(edmProperty),
                  code.Escape(edmProperty.TypeUsage),
                  code.Escape(edmProperty),
                  code.SpaceAfter(Accessibility.ForGetter(edmProperty)),
                  code.SpaceAfter(Accessibility.ForSetter(edmProperty)));
}

void WriteNavigationProperty(EntityType entity, string keyField, CodeGenerationTools code, NavigationProperty navigationProperty)
{
    var endType = code.Escape(navigationProperty.ToEndMember.GetEntityType());
	 var endTypeVo = endType +  "Vo";

	string prop =  code.Escape(navigationProperty);
	 prop =  prop.Substring(0,1).ToLower() + prop.Substring(1);

	 string nprop = "";
	
	 if(navigationProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many){
		
	nprop = "List<" + endTypeVo + ">";
	 
#>
    [Association("<#=code.Escape(entity)#>_<#=endType#>", "<#=keyField#>", "<#=keyField#>")]
<#+
} else {
   nprop = endTypeVo;
#>
    [ForeignKey("<#=prop#>Id")]
<#+
  }

    WriteProperty(PropertyVirtualModifier(Accessibility.ForProperty(navigationProperty)),
                  nprop,
                  prop,
                  code.SpaceAfter(Accessibility.ForGetter(navigationProperty)),
                  code.SpaceAfter(Accessibility.ForSetter(navigationProperty))
	 );
	 #>
   
<#+
}


void WriteProperty(string accessibility, string type, string name, string getterAccessibility, string setterAccessibility)
{
/// ei:  public string name
#>
    <#=accessibility#> <#=type.Replace("System.","")#> <#=name#> { <#=getterAccessibility#>get; <#=setterAccessibility#>set; }
<#+
}


string PropertyVirtualModifier(string accessibility)
{
	return "public"; //mine
    return accessibility + (accessibility != "private" ? " virtual" : "");
}

bool VerifyTypesAreCaseInsensitiveUnique(EdmItemCollection itemCollection)
{
    var alreadySeen = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
    foreach(var type in itemCollection.GetItems<StructuralType>())
    {
        if (!(type is EntityType || type is ComplexType))
        {
            continue;
        }

        if (alreadySeen.ContainsKey(type.FullName))
        {
            Error(String.Format(CultureInfo.CurrentCulture, "This template does not support types that differ only by case, the types {0} are not supported", type.FullName));
            return false;
        }
        else
        {
            alreadySeen.Add(type.FullName, true);
        }
    }

    return true;
}
#>
